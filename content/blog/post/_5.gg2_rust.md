---
description: TEST
date: October 4, 2024 00:00 EDT
tags:
 - gg2
 - gang-garrison-2
 - blog
 - devlog
 - rust-lang
 - rust
 - programming
---

# Gang Garrison Rust

[Gang Garrison 2](https://en.wikipedia.org/wiki/Gang_Garrison_2) (<abbr title="Gang Garrison 2">GG2</abbr>) is a demake of the game [Team Fortress 2](https://en.wikipedia.org/wiki/Team_Fortress_2) (<abbr>TF2</abbr>). It was originally developed as a entry for 2008 TIGSource "Bootleg Demake" jam but continued development through open-source.

I consider myself a die-hard <abbr title="Team Fortress 2">TF2</abbr> player. With a grand total of 72 minutes in the game, I know a thing or two. In addition, I've never played <abbr title="Gang Garrison 2">GG2</abbr> properly. So you might ask why would I take notice of this game? Well just like everything else I've done in my life "I was bored."

One of my [friends](https://github.com/Minecraftboss318)&mdash;named Alec&mdash;is the real die-hard <abbr title="Team Fortress 2">TF2</abbr>/<abbr title="Gang Garrison 2">GG2</abbr> fan and I've heard my fair share about both games from him. Over a year ago, he started development on what would become his Python rewrite of the [server](https://github.com/Minecraftboss318/gg2-python-dedicated-server). He did this largely because <abbr title="Gang Garrison 2">GG2</abbr> lacked a dedicated server. Unlike an integrated server that runs inside of a client, a dedicated server is an independent program that could be ran for instance in a terminal.

Some important context on <abbr title="Gang Garrison 2">GG2</abbr> is that it was built on [GameMaker](https://en.wikipedia.org/wiki/GameMaker) 8. This is a massively outdated game engine released in late 2009. GameMaker isn't regarded as the most portable game engine ever. It mostly is only good for Windows development.[^1] The single biggest reason why <abbr title="Gang Garrison 2">GG2</abbr> can't be ported to platforms such as Linux is that it's stuck on this old game engine. This isn't just a portability concern either. GameMaker 8 isn't capable of running without graphics (i.e a dedicated server) and has performance issues with large amounts of players.

## Which Game Engine Is Right

Your first thought might be [Unity](https://en.wikipedia.org/wiki/Unity_(game_engine)), [Unreal](https://en.wikipedia.org/wiki/Unreal_Engine), or even [Godot](https://en.wikipedia.org/wiki/Godot_(game_engine)), but each of these have incompatibilities. Unity&mdash;and Unreal frankly&mdash;suffers from the age ol' problem of capitalism. I frankly don't trust Unity in the long term to make healthy decisions for developers and gamers. So Godot wins by default, right? Well, no. I do love Godot, but it's meant for making Godot games and not GameMaker games. <abbr title="Gang Garrison 2">GG2</abbr> and GameMaker have a very specific way of doing networking, physics, and much more. It would be hard for any of these three game engines to act like a completely different one. A much lower level game engine is required.

If the main big game engines don't work then why not make it from scratch. Since I fairly comfortable with Rust, I already knew that I would probably be using it. I could create a Rust game with Vulkan and have full control over the entire stack. Trouble is: this would be a huge under taking; there's a reason game engines exist. A balance between complete control and development time was apparent.

Being in the Rust ecosystem has made me aware&mdash;and even try out&mdash;[Bevy](https://bevyengine.org/) the game engine. It's a very rustic approach to a game engine and features an [entity component system](https://en.wikipedia.org/wiki/Entity%20component%20system) (<abbr>ECS</abbr>). The important aspect of Bevy is that it offers a high level of modularity compared to most other game engines. Bevy at its heart is just an <abbr title="entity component system">ECS</abbr>, but offers many plugins that can be added to bring it up to a full blown game engine. With me having prior experience with it and it offering the right level of control, I felt that this more than warranted its use.

## The Networking Stack

<abbr title="Gang Garrison 2">GG2</abbr>'s client is nothing without being able to talk to a server. I felt that it would be a good test to make sure I'm up for the task of remaking a video game. Firstly though, who does the client and server even communicate and what do they even say? I read though both Alec's server and the [official code base](https://github.com/Gang-Garrison-2/Gang-Garrison-2) to answer this very question. Alec himself also helped me along in our frequent chats.

The underlying way the client and server talk is through a [TCP WebSocket](https://en.wikipedia.org/wiki/WebSocket). To put it simply: it's a two way pipe for raw bytes to be sent back and forth. [TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol) isn't favored by games since its slow speeds, but for what <abbr title="Gang Garrison 2">GG2</abbr>, does it should be fine.[^2] Anyways, like many of the less favorable decisions I've been forced to make, <abbr title="Gang Garrison 2">GG2</abbr> only supports this method.

The server and client send packets of data that we'll call messages. A message is simply an 8-bit number defining the message kind and then a payload of dynamic length. We'll cover some examples [later](#player-joining).

Bevy offers a high amount of modularity compared to other game engines. At its core, Bevy is really just an <abbr title="entity component system">ECS</abbr>. This means that textures, scheduling, physics, and more are all added with plugins instead of being included with the core of the engine. So I'll need to either find a WebSocket plugin for Bevy or make my own. Using an already made crate would be preferable.

[Spicy Networking for Bevy](https://github.com/cabbitstudios/bevy_spicy_networking) looks like a perfect fit at first glance with it using <abbr>TCP</abbr> and meant for Bevy. After looking at it for a little longer, issues arise. Firstly, it hasn't been updated in 3 years. Secondly, it provides its own solution for determining message kinds. It's messages contain the length of the entire packet, a string of the message kind, and a payload. Even with the crate utilizing a different message structure, it's still a good starting place.

I decided that it would be best to write something new while following Spicy Networking as a blueprint. The first part of the networking stack I started working on was the network client; not to be confused the game client, it's where all the packets of data will be sent and received. The reason it has to be separate from the game client is since it's [asynchronous](https://en.wikipedia.org/wiki/Asynchrony_(computer_programming)). This requires a runtime which Bevy doesn't provide. So whenever the client wants to connect to a sever, it whirs up the network client. This spawns a [Tokio](https://tokio.rs) runtime which splits into two worker threads. One packages messages from Bevy to be sent off to the server and the other receives messages and passes them off to Bevy.

After frankensteining the code together to work both with a modern version of Bevy and with <abbr title="Gang Garrison 2">GG2</abbr>'s message format, I was ready to start implementing some messages and send them off to the server. The best place to start is the player joining handshake since it's the first thing the server and client do.

## Player Joining

The goal is to establish a network connection with a server and have a player join as a spectator.

![[Projects/GG2 Rust/GG2 Network Messages.webp]]

The handshake looks something like the above. Once connected to the socket, the client sends `HELLO`. The server responds with some basic information. The message kind get inserted/collected before all packets are serialized/deserialized. So only the payload needs to be implemented for each message. Right now we only need to worry about serializing client packets and deserializing server packets since this is just a client. There is the possibility of implementing the other half of the networking stack, but this is out of the projects scope for now.

Client -> Server:

```rust
pub struct ClientHello {
    pub protocol: Uuid,
}

impl GGMessage for ClientHello {
    const KIND: PacketKind = PacketKind::Hello;

    // 0x00, [128-bit protocol UUID]
    fn serialize(self, buffer: &mut Vec<u8>) -> Result<()> {
        let protocol_bytes = self.protocol.into_bytes();
        buffer.extend(protocol_bytes.iter());
        Ok(())
    }
}
```

Server -> Client:

```rust
pub struct ServerHello {
    pub server_name: String,
    pub map_name: String,
    pub map_md5: Option<u128>,
    pub plugins: Vec<()>,
}

impl GGMessage for ServerHello {
    const KIND: PacketKind = PacketKind::Hello;

    // 0x00,
    // [8-bit string length], [server name],
    // [8-bit string length], [map MD5 string],
    // [8-bit number of plugins],
    // [16-bit string length], [plugins string]
    fn deserialize<I: Iterator<Item = u8>>(payload: &mut I) -> Result<Self> {
        let server_name = payload.read_utf8_short_string()?;
        let map_name = payload.read_utf8_short_string()?;

        let map_md5 = payload.read_md5()?;

        let _plugins_amounts = payload.next().ok_or(Error::UnexpectedEOF)?;
        let _plugins_raw = payload.read_utf8_long_string()?;

        Ok(Self {
            server_name,
            map_name,
            map_md5,
            plugins: Vec::new(), // Plugins not implemented yet.
        })
    }
}
```

Once we get the server information from the `HELLO`, we send a `RESERVE_SLOT`. This just contains the player name. The server responds with an empty message of the same type. This tells the client that it's time to send an empty `PLAYER_JOIN` message.

At this point the player is connected to the server, but we don't know what's going on. The server sends back many packets from here on out. If we are just spectating, then there's no need to send anything else. The server will send back messages such as `CHANGE_MAP`, `JOIN_UPDATE`, `PLAYER_CHANGE_CLASS`, `PLAYER_CHANGE_TEAM`, `FULL_UPDATE`, and lastly `MESSAGE STRING`. These all tell the client the full current state of the server. After this, the server  sends infrequent messages to keep the client state in sync with the server's. We will look at these later.

## Map Loading

We're given a lot of information about what is going on with the server, but it's all useless without actually showing. This is why I decided to start focusing on map loading.

Maps in <abbr title="Gang Garrison 2">GG2</abbr> are images with extra metadata describing wall collisions and more. It's all stored within a <abbr>PNG</abbr> making maps very portable.[^3] Loading an image is very simple in Bevy, but the metadata no so much.

Bevy has assets, such as images and models, which can be loaded with the asset server. You can create custom assets and loaders to suit your needs. I opted to go this direction since it will plays nicely with the Bevy ecosystem. Essentially, Bevy gives a async buffer of the raw asset and it's your job to deserialize it.

A <abbr>PNG</abbr> is made up of a bunch of chunks that contain different information such as image data, timestamps, and more. The one we care about is `zTXt`. [^4] It's described as storing compressed text. It has a byte the defines which compression method is used. The only one provided by the <abbr>PNG</abbr> spec so far is a zlib deflate datastream.

This is were I would say I found a crate that did all of this for me. Which yes there is [one](https://docs.rs/png/latest/png/text_metadata/struct.ZTXtChunk.html), but I noticed this only after implementing my own <abbr>PNG</abbr> parser. There is a chance that my is faster given that it's hyper-focused on only one thing, but that has yet to be tested. Let's just say it's 500% better in some metric so I don;t have to ever touch that thing again.

The first thing we need to do is confirm the file is even a <abbr>PNG</abbr> at all. This can be done by checking the file's signature 

## Walk Mask



[^1]: MacOS is also supported but <abbr title="Gang Garrison 2">GG2</abbr> doesn't currently support it.
[^2]: [UDP](https://en.wikipedia.org/wiki/User_Datagram_Protocol) is much faster and would be better suited for video games. It can result in more complicated networking though.
[^3]: Some websites strip this data when you upload an image, so it's not perfect.
[^4]: https://www.w3.org/TR/png-3/#11zTXt--
